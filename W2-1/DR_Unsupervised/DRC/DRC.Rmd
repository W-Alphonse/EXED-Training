---
title: "Dimension Reduction and Clustering"
author: "E. Le Pennec"
date: "Spring 2019"
output: html_document
---
---
```{r Knitr_Global_Options, include=FALSE}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE, autodep = TRUE, tidy = FALSE)
library(rgl)
knit_hooks$set(webgl = hook_webgl)
```

# Dimension Reduction

## PCA

```{r Decathlon}
library(FactoMineR)
data("decathlon")    # donnée qu'on veut clusterise
summary(decathlon)
head(decathlon)

# On fait du scaling pour eliminer le 
decathlonR <- decathlon
decathlonR[1:10] <- scale(decathlon[1:10], center = TRUE)
```

```{r SwissRoll, webgl = TRUE}
library("spe")
data("swissroll")
library("rgl")
swissroll <- swissroll[order(swissroll$z),]
plot3d(swissroll, col = plotrix::color.scale(1:nrow(swissroll),c(0,1,1),c(1,1,0),0))
```

# https://stackoverflow.com/questions/42560090/what-is-the-meaning-of-the-dollar-sign-in-r-function
# The $ allows you extract elements by name from a named list. For example
# x <- list(a=1, b=2, c=3)
# x$b => # [1] 2
# You can find the names of a list using names() : names(x) # => [1] "a" "b" "c"
# This is a basic extraction operator. You can view the corresponding help page by typing ?Extract in R.
# ----------------------------------------------------------------------------------------------------


```{r Clusters}
library("tidyverse")
Clusters <- read_delim("donclassif.txt.gz", ";") # "donclassif.txt.gz" contains features --> "V1";"V2"
PlotClusters <- function(CoordPoints, col = NULL) {
  if (is.null(col)) {
    # sample takes a sample of the specified size 
    col = sample(1:nrow(CoordPoints))   # nrow/ncol return the number of rows or columns present in x.NCOL and x.NROW
  }
  ggplot(data.frame(X = CoordPoints[, 1, drop = TRUE],  # => For all rows of CoordPoints, X is equal to "V1". drop=TRUE => It means that allows to downsize the object returned by CoordPoints[, 1]
                    Y = CoordPoints[, 2, drop = TRUE],
                    Col = col),
         aes(x = X, y = Y)) + 
    geom_point(aes(color = Col), size = 2) + guides(color = FALSE) + 
    coord_fixed()       # coord_fixed : Cartesian coordinates with fixed "aspect ratio"
}

PlotClusters(Clusters)
```

```{r Plot}
PlotDecathlon <- function(CoordPoints, col = NULL) {
  if (is.null(col)) {
    col = decathlon$Points
  }
  ggplot(data = data.frame( X = CoordPoints[, 1, drop = TRUE],
                            Y = CoordPoints[, 2, drop = TRUE],
                            Col = col),
         aes(x = X, y = Y)) + 
    geom_point(aes(color = Col), size = 5) + geom_text(label = row.names(decathlon), vjust = -1.25) +
    scale_x_continuous(expand = c(.15,0)) + scale_y_continuous(expand = c(.1,0)) +
    guides(color = FALSE) +
    coord_fixed()
}

PlotSwissRoll <- function(CoordPoints, Col = NULL) {
  if (is.null(Col)) {
    Col = 1:nrow(swissroll)
  }
  ggplot(data = data.frame( X = CoordPoints[, 1, drop = TRUE],
                            Y = CoordPoints[, 2, drop = TRUE],
                            Col = Col),
         aes(x = X, y = Y)) + 
    geom_point(aes(color = Col), size = 5) + guides(color = FALSE) +
    coord_fixed()
}
```


```{r PCA}
# ----------------------------------------------------------------------------------------------
# PCA: Performs Principal Component Analysis (PCA) with supplementary individuals, supplementary 
#      quantitative variables and supplementary categorical variables.
#      Missing values are replaced by the column mean.
#      It computes PCA scaling automatically + Plot explicitely the graph of Individuals and Variables
# ----------------------------------------------------------------------------------------------
DecathlonPCA <- PCA(decathlon[1:10])  # Arg : data frame with n rows (individuals) and p columns (numeric variables)
PlotDecathlon(DecathlonPCA$ind$coord) # $ind : a list of matrices containing all the results for the active individuals (coordinates, square cosine, contributions)
#plot(DecathlonPCA)

# decathlonR = decathlon + scaled explicitely / scale(decathlon, center=TRUE)
DecathlonRPCA <- PCA(decathlonR[1:10])
PlotDecathlon(DecathlonRPCA$ind$coord)
 
SwissRollPCA <- PCA(swissroll)
PlotSwissRoll(SwissRollPCA$ind$coord)
# 
ClustersPCA <- PCA(Clusters)  # clusters = "donclassif.txt.gz" it contains the features "V1";"V2"
PlotClusters(ClustersPCA$ind$coord)
```


```{r}
DecathlonPCA$eig
DecathlonPCA$var
# ceci permet d'identifier l'apport de chaque dimension
```
```{r}
DecathlonPCA$call$centre
DecathlonPCA$call$ecart.type
DecathlonPCA$call$row.w
DecathlonPCA$call$col.w
#DecathlonPCA$var
```
```{r}
# DecathlonPCA$var
DecathlonPCA$ind
```


## MFA

```{r Poison}
data(poison)     # load the dataset poison
summary(poison)  # summarize the dataset poison
head(poison)
names(poison)    # Get or set the names of an object
```
#Comme les données sotn ctageorielle, alors il faut les transformer pour passer en grandeur numerique
# Il faut definir les groupe

```{r MFA}
#poison_features = poison[,c[1,4:15]]
PoisonMFA <- MFA(poison,
                 group=c(2,2,5,6),         # on indique combien de variable il y a ds chaque groupe
                 type=c("s","n","n","n"),  # s:variable continue, n:variable categorielle,
name.group=c("Age_Time","Sick_Sex","Symptom","Eat"))
# PoisonMFA <- MFA(poison, 
#                  group=c(1,1,2,5,6),         # on indique combien de variable il y a ds chaque groupe
#                  type=c("s","s","n","n","n"),  # s:variable continue, n:variable categorielle, 
# name.group=c("Age","Time", "Sick_Sex","Symptom","Eat"))

# graph = true
```
# groupc(2,  --> "Age"        "Time"
#        2,  --> "Sick"       "Sex"
#        5,  --> "Nausea"     "Vomiting"   "Abdominals" "Fever"      "Diarrhae""
#        6)  --> "Potato"     "Fish"       "Mayo"       "Courgette"  "Cheese"     "Icecream" 


```{r}
# Par la suite, essayer de choisir qlq points du centre de chaque cluster afin d'interpreter le resultat
# cluster 1
poison[c(14,20),]
# cluster 2
poison[c(5,55),]
```



## ICA - Independent Component Analysis (ICA) 

```{r ICA}
library("fastICA")
DecathlonICA <- fastICA(decathlon[1:10], n.comp = 2)  # n.comp = number of components to be extracted
PlotDecathlon(DecathlonICA$S)
# 
DecathlonRICA <- fastICA(decathlonR[1:10], n.comp = 2)
PlotDecathlon(DecathlonRICA$S)
# 
SwissRollICA <- fastICA(swissroll, n.comp = 2)
PlotSwissRoll(SwissRollICA$S)
# 
ClustersICA <- fastICA(Clusters, n.comp = 2)
PlotClusters(ClustersICA$S)
```

<!-- PCA weaknesses -->
<!-- • Only allows linear projections -->

<!-- • Co-variance matrix is of size dxd. If d=104 -->
<!-- , then |Σ| = 108 -->
<!-- • Solution: singular value decomposition (SVD) -->

<!-- • PCA restricts to orthogonal vectors in feature space that minimize -->
<!-- reconstruction error -->
<!-- • Solution: independent component analysis (ICA) seeks directions -->
<!-- that are statistically independent, often measured using -->
<!-- information theory -->

<!-- • Assumes points are multivariate Gaussian -->
<!-- • Solution: Kernel PCA that transforms input data to other spaces -->


## NMF: PCA and NMF optimize for a different result. PCA finds a subspace which conserves the variance of the data, while NMF finds nonnegative features.

```{r NMF}
library("NMF")
DecathlonNMF <- nmf(decathlon[1:10], rank = 2)
PlotDecathlon(basis(DecathlonNMF))
```

## k-PCA

```{r KPCA}
library("kernlab")
DecathlonKPCA <- kpca(decathlon[1:10], features = 2)
PlotDecathlon(as.matrix(scale(decathlon[1:10], scale = FALSE)) %*% pcv(DecathlonKPCA))

DecathlonRKPCA <- kpca(decathlonR[1:10], features = 2)
PlotDecathlon(as.matrix(scale(decathlonR[1:10], scale = FALSE)) %*% pcv(DecathlonRKPCA))

SwissRollKPCA <- kpca(swissroll, features = 2)
PlotSwissRoll(as.matrix(scale(swissroll, scale = FALSE)) %*% pcv(SwissRollKPCA))

```

## Deep Learning: PCA and autoencoders

```{r Keras}
#library(keras)
```

```{r Keras_PCA}
# pca_encoder <-  keras_model_sequential() %>%
#   layer_dense(units = 2, input_shape = c(10))
# pca_decoder <- keras_model_sequential() %>% layer_dense(units = 10, input_shape = c(2))
# pca_autoencoder <- keras_model_sequential() %>% pca_encoder() %>% pca_decoder()
# 
# pca_autoencoder %>% compile(loss = "mse", optimizer = "sgd",
#                         metric= "mse")
# 
# decathlonR100 <- decathlonR %>% slice(rep(seq_len(nrow(decathlonR)),100))
# 
# pca_hist <- pca_autoencoder %>% fit(x = as.matrix(decathlonR100[,1:10]),
#                                     y= as.matrix(decathlonR100[,1:10]),
#                                     epochs = 1000,
#                                     batch_size = 32,
#                                     verbose = 0)
```

```{r keras_pca_plot}
# decathlon_pca_coords <- predict(pca_encoder, x = as.matrix(decathlonR[,1:10]))
# PlotDecathlon(decathlon_pca_coords)
```


```{r keras_ae}
# encoder <- keras_model_sequential() %>%
#   layer_dense(units = 4, activation = "relu", input_shape = c(10)) %>%
#   layer_dense(units = 2)
# decoder <- keras_model_sequential() %>%
#   layer_dense(units = 4, activation = "relu", input_shape = c(2)) %>%
#   layer_dense(units = 10)
# autoencoder <- keras_model_sequential() %>% encoder %>% decoder()
# 
# autoencoder %>% compile(loss = "mse", optimizer = "sgd",
#                         metric= "mse")
# 
# ae_hist <- autoencoder %>% fit(x = as.matrix(decathlonR100[,1:10]),
#                             y= as.matrix(decathlonR100[,1:10]),
#                             epochs = 5000,
#                             batch_size = 32,
#                             verbose = 0)
```

```{r keras_ae_plot}
# decathlon_ae_coords <- predict(encoder, x = as.matrix(decathlonR[,1:10]))
# PlotDecathlon(decathlon_ae_coords)
```


## MDS

```{r MDS}
DistDecathlon <- dist(decathlon[1:10])
DecathlonMDS <- cmdscale(DistDecathlon, k = 2)
PlotDecathlon(DecathlonMDS)

DistDecathlonR <- dist(decathlonR[1:10])
DecathlonRMDS <- cmdscale(DistDecathlonR, k = 2)
PlotDecathlon(DecathlonRMDS)

DistSwissRoll <- dist(swissroll)
SwissRollMDS <- cmdscale(DistSwissRoll, k = 2)
PlotSwissRoll(SwissRollMDS)

DistClusters <- dist(Clusters)
DistUClusters <- dist(unique(Clusters))
ClustersMDS <- cmdscale(DistClusters, k = 2)
PlotClusters(ClustersMDS)
```

## ISOMAP

```{r ISOMAP}
library("vegan")
DecathlonISOMAP <- isomap(DistDecathlon, ndim = 2, k = 5)
PlotDecathlon(DecathlonISOMAP$points)

DecathlonRISOMAP <- isomap(DistDecathlonR, ndim = 2, k = 5)
library("ggplot2")
PlotDecathlon(DecathlonRISOMAP$points)

SwissRollISOMAP <- isomap(DistSwissRoll, ndim = 2, k = 10)
PlotSwissRoll(SwissRollISOMAP$points)
```


## Random Projection

```{r RandomProj}
library("chemometrics")
DecathlonRandom <- RPvectors(2, 10)
PlotDecathlon(as.matrix(decathlon[1:10]) %*% DecathlonRandom)

PlotDecathlon(as.matrix(decathlonR[1:10]) %*% DecathlonRandom)

SwissRollRandom <- RPvectors(2, 3)
PlotSwissRoll(as.matrix(swissroll) %*% SwissRollRandom)

ClustersRandom <- RPvectors(2, 2)
PlotClusters(as.matrix(Clusters) %*% ClustersRandom)
```

## LLE : Locally Linear Embedding

```{r LLE}
library("lle")
DecathlonLLE <- lle(decathlon[1:10], m = 2, k = 10)
PlotDecathlon(DecathlonLLE$Y)

DecathlonRLLE <- lle(decathlonR[1:10], m = 2, k = 10)
PlotDecathlon(DecathlonRLLE$Y)

SwissRollLLE <- lle(swissroll, m = 2, k = 10)
PlotSwissRoll(SwissRollLLE$Y)

ClustersLLE <- lle(Clusters, m = 2, k = 10)
PlotClusters(ClustersLLE$Y)
```


## t-SNE : t-Stochastic Neighbor Embedding

```{r TSNE}
library("Rtsne")
DecathlonTSNE <- Rtsne(as.matrix(decathlon[1:10]), perplexity = 10, pca = FALSE)
PlotDecathlon(DecathlonTSNE$Y)

DecathlonRTSNE <- Rtsne(as.matrix(decathlonR[1:10]), perplexity = 10, pca = FALSE)
PlotDecathlon(DecathlonRTSNE$Y)

SwissRollTSNE <- Rtsne(as.matrix(swissroll), perplexity = 30, pca = FALSE)
PlotSwissRoll(SwissRollTSNE$Y)

ClustersTSNE <- Rtsne(as.matrix(unique(Clusters)), perplexity = 30, pca = FALSE)
PlotSwissRoll(ClustersTSNE$Y, Col = 1:nrow(unique(Clusters)))
```

## UMAP : Uniform Manifold Approximation and Projection

```{r}
library(uwot)

DecathlonUMAP <- umap(as.matrix(decathlon[1:10]))
PlotDecathlon(DecathlonUMAP)

DecathlonRUMAP <- umap(as.matrix(decathlonR[1:10]))
PlotDecathlon(DecathlonRUMAP)

SwissRollUMAP <- umap(as.matrix(swissroll))
PlotSwissRoll(SwissRollUMAP)

ClustersUMAP <- umap(as.matrix(unique(Clusters)))
PlotSwissRoll(ClustersUMAP, Col = 1:nrow(unique(Clusters)))
```
```{r}
Clusters$color = rep(0,nrow(Clusters))
Clusters$color[c(1:50)] = 1
Clusters$color[c(410:560)] = 2
ggplot(Clusters, aes(V1,V2, col=as.factor(color))) + geom_point()
```

```{r}
ClustersUMAP = as_tibble(ClustersUMAP)
ClustersUMAP$color = rep(0,nrow(ClustersUMAP))
ClustersUMAP$color[c(1:50)] = 1
ClustersUMAP$color[c(410:560)] = 2
ggplot(ClustersUMAP, aes(V1,V2, col=as.factor(color))) + geom_point()
```

#  Graph

```{r Laplacian}
library("igraph")
DecathlonLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistDecathlon/3)), weighted = TRUE),2)
PlotDecathlon(DecathlonLap$X)
DecathlonRLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistDecathlonR/3)), weighted = TRUE),2)
PlotDecathlon(DecathlonRLap$X)
SwissRollLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistSwissRoll/3)), weighted = TRUE),2)
PlotSwissRoll(SwissRollLap$X)
```


# Clustering

## K-Means

```{r KMeans}
K <- 4
K2 <- 10

DecathlonRKmeans <- kmeans(decathlonR[1:10], K)  # Kmeans sur ttes les variables
PlotDecathlon(DecathlonRPCA$ind$coord, col = factor(DecathlonRKmeans$cluster))  # je represente sur ces axes

DecathlonRPCAKmeans <- kmeans(DecathlonRPCA$ind$coord[,1:2], K)
PlotDecathlon(DecathlonRPCA$ind$coord, col = factor(DecathlonRPCAKmeans$cluster))

PlotDecathlon(DecathlonTSNE$Y, col = factor(DecathlonRKmeans$cluster))

DecathlonTSNEKmeans <- kmeans(DecathlonTSNE$Y, K)
PlotDecathlon(DecathlonTSNE$Y, col = factor(DecathlonTSNEKmeans$cluster))

PlotDecathlon(DecathlonRPCA$ind$coord, col = factor(DecathlonTSNEKmeans$cluster))

ClustersKmeans <- kmeans(Clusters, K2)
PlotClusters(Clusters, col = factor(ClustersKmeans$cluster))

ClustersTSNEKmeans <- kmeans(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), col = factor(ClustersTSNEKmeans$cluster))
```

## PAM
# k-Medoid: Ago plus robuste aux pts abhérent

```{r PAM}
DecathlonRPam <- pam(decathlonR[1:10], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRPam$cluster))

DecathlonRPCAPam <- pam(DecathlonRPCA$ind$coord[,1:2], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRPCAPam$cluster))

DecathlonTSNEPam <- pam(DecathlonTSNE$Y, K)
PlotDecathlon(DecathlonTSNE$Y, Col = factor(DecathlonTSNEPam$cluster))

ClustersPam <- kmeans(Clusters, K2)
PlotClusters(Clusters, Col = factor(ClustersPam$cluster))

ClustersTSNEPam <- kmeans(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), Col = factor(ClustersTSNEPam$cluster))
```

```{r}
# TO COMPLETE : PLOT de La sihoulette. Il permet d evaluer quelle methode de clustering est la meilleure
library(cluster)

distances = dist(decathlonR[1:10])
K=15
DecathlonRKmeans <- kmeans(decathlonR[1:10], K)
DecathlonTSNEKmeans <- kmeans(DecathlonTSNE$Y, K)

# Error in data.frame(X = CoordPoints[, 1, drop = TRUE], Y = CoordPoints[, : arguments imply differing number of rows: 0, 41
# PlotDecathlon(DecathlonRKmeans$ind$coord , col=factor(DecathlonRKmeans$cluster)) 
# PlotDecathlon(DecathlonTSNEKmeans$ind$coord , col=factor(DecathlonTSNEKmeans$cluster)) 

plot(silhouette(DecathlonRKmeans$cluster,distances))
plot(silhouette(DecathlonTSNEKmeans$cluster,distances))

```

## GMM

```{r GMM}
# Gaussien Mixture Model
# Sachant le nro de Cluster, mes Xi sont Gaussians, 
library("Rmixmod")
DecathlonGMM <- mixmodCluster(decathlon[1:10], K)
PlotDecathlon(DecathlonPCA$ind$coord, col = factor(DecathlonGMM@bestResult@partition))

DecathlonRGMM <- mixmodCluster(decathlonR[1:10], K)
PlotDecathlon(DecathlonRPCA$ind$coord, col = factor(DecathlonRGMM@bestResult@partition))

ClustersGMM <- mixmodCluster(Clusters, K2)
# Error in data.frame(X = CoordPoints[, 1, drop = TRUE], Y = CoordPoints[, : arguments imply differing number of rows: 2800, 0
PlotClusters(Clusters, col = factor(ClustersGMM@bestResult@partition))
```

## PLSA / LDA : Linear Discriminant Analysis 

```{r LDA}
library(topicmodels)
data("AssociatedPress")
# AssociatedPress: 2246 documents avec 10473 words
k = 5  # topics count
ap_lda <- LDA(AssociatedPress, k , control = list(seed = 1234))
ap_lda
terms(ap_lda,10)
```

## DBSCAN : Generates a density based clustering of arbitrary shape
# Calcul du nbre de points ds les petites feentres, ensite faire avancer les fenetre, dès qu'il n'y a plus de pts, ceci voudrait dire que la frontiere du cluter a été atteinte
```{r DBSCAN}
library("fpc")

DecathlonDBScan <- dbscan(decathlon[1:10], 10)
PlotDecathlon(DecathlonPCA$ind$coord, col = factor(DecathlonDBScan$cluster))

DecathlonRDBScan <- dbscan(decathlonR[1:10], 3)
PlotDecathlon(DecathlonRPCA$ind$coord, col = factor(DecathlonRDBScan$cluster))

ClustersDBScan <- dbscan(Clusters, .2)
PlotClusters(Clusters, col = factor(ClustersDBScan$cluster))

ClustersTSNEDBScan <- dbscan(ClustersTSNE$Y, 2)
PlotClusters(unique(Clusters), col = factor(ClustersTSNEDBScan$cluster))
```

## PdfCluster

```{r PdfCluster}
library("pdfCluster")
ClustersPdf <- pdfCluster(Clusters)
PlotClusters(Clusters, col = factor(ClustersPdf@clusters))
```

## Mean Shift
```{r MeanShift}
library("LPCM")
ClustersMS <- ms(Clusters, h = .04)
PlotClusters(Clusters, col = factor(ClustersMS$cluster.label))
```


## Linkage
# Agglomerative Cluster
```{r Linkage}
library("ggdendro")
library("fastcluster")
ClustersMLD <- hclust(DistClusters, method = "single")
ggdendrogram(ClustersMLD)
ClustersML <- cutree(ClustersMLD, k = K2)
PlotClusters(Clusters, col = factor(ClustersML))

ClustersALD <- hclust(DistClusters, method = "average")
ggdendrogram(ClustersALD)
ClustersAL <- cutree(ClustersALD, k = K2)
PlotClusters(Clusters, col = factor(ClustersAL))

ClustersMMLD <- hclust(DistClusters, method = "complete")
ggdendrogram(ClustersMMLD)
ClustersMML <- cutree(ClustersMMLD, k = K2)
PlotClusters(Clusters, col = factor(ClustersMML))
```

## WARD

```{r Ward}
ClustersWardD <- hclust(DistClusters, method = "ward.D2")
ggdendrogram(ClustersWardD)
ClustersWard <- cutree(ClustersWardD, k = K2)
PlotClusters(Clusters, col = factor(ClustersWard))
```

## DIANA

```{r Diana}
ClustersDianaD <- as.hclust(diana(Clusters))
ggdendrogram(ClustersDianaD)
ClustersDiana <- cutree(ClustersDianaD, k = K2)
PlotClusters(Clusters, col = factor(ClustersDiana))
```

## Affinity Propagation

```{r AffProp}
library("apcluster")
ClustersAF <- apcluster(negDistMat(r=2), Clusters)
PlotClusters(Clusters, labels(ClustersAF))
```


## CLARA

```{r Clara}
ClustersClara <- clara(Clusters, K2)
PlotClusters(Clusters, col = factor(ClustersClara$clustering))

ClustersSNEClara <- clara(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), col = factor(ClustersSNEClara$clustering))
```

