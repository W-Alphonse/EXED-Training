---
title: "Dimension Reduction and Clustering"
author: "E. Le Pennec"
date: "Spring 2019"
output: html_document
---
---
```{r Knitr_Global_Options, include=FALSE}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE, autodep = TRUE, tidy = FALSE)
library(rgl)
knit_hooks$set(webgl = hook_webgl)
```

# Dimension Reduction

## PCA

```{r Decathlon}
library(FactoMineR)
data("decathlon")    # donnée qu'on veut clusterise
summary(decathlon)
head(decathlon)

# On fait du scaling pour eliminer le 


decathlonR <- decathlon
decathlonR[1:10] <- scale(decathlon[1:10], center = TRUE)
```

```{r SwissRoll, webgl = TRUE}
library("spe")
data("swissroll")
library("rgl")
swissroll <- swissroll[order(swissroll$z),]
plot3d(swissroll, col = plotrix::color.scale(1:nrow(swissroll),c(0,1,1),c(1,1,0),0))
```

```{r Clusters}
library("tidyverse")
Clusters <- read_delim("donclassif.txt.gz", ";")
PlotClusters <- function(CoordPoints, Col = NULL) {
  if (is.null(Col)) {
    Col = sample(1:nrow(CoordPoints))
  }
  ggplot(data.frame(X = CoordPoints[, 1, drop = TRUE],
                    Y = CoordPoints[, 2, drop = TRUE],
                    Col = Col),
         aes(x = X, y = Y)) + 
    geom_point(aes(colour = Col), size = 2) + guides(color = FALSE) +
    coord_fixed()
}

PlotClusters(Clusters)
```

```{r Plot}
PlotDecathlon <- function(CoordPoints, Col = NULL) {
  if (is.null(Col)) {
    Col = decathlon$Points
  }
  ggplot(data = data.frame( X = CoordPoints[, 1, drop = TRUE],
                            Y = CoordPoints[, 2, drop = TRUE],
                            Col = Col),
         aes(x = X, y = Y)) + 
    geom_point(aes(colour = Col), size = 5) + geom_text(label = row.names(decathlon), vjust = -1.25) +
    scale_x_continuous(expand = c(.15,0)) + scale_y_continuous(expand = c(.1,0)) +
    guides(color = FALSE) +
    coord_fixed()
}

PlotSwissRoll <- function(CoordPoints, Col = NULL) {
  if (is.null(Col)) {
    Col = 1:nrow(swissroll)
  }
  ggplot(data = data.frame( X = CoordPoints[, 1, drop = TRUE],
                            Y = CoordPoints[, 2, drop = TRUE],
                            Col = Col),
         aes(x = X, y = Y)) + 
    geom_point(aes(colour = Col), size = 5) + guides(color = FALSE) +
    coord_fixed()
}
```


```{r PCA}
DecathlonPCA <- PCA(decathlon[1:10])
PlotDecathlon(DecathlonPCA$ind$coord)
#plot(DecathlonPCA)

DecathlonRPCA <- PCA(decathlonR[1:10])
PlotDecathlon(DecathlonRPCA$ind$coord)

SwissRollPCA <- PCA(swissroll)
PlotSwissRoll(SwissRollPCA$ind$coord)

ClustersPCA <- PCA(Clusters)
PlotClusters(ClustersPCA$ind$coord)
```

# DecathlonPCA$eig
# ceci permet d'identifier l'apport de chaque dimension

## MFA

```{r Poison}
data(poison)
summary(poison)
head(poison)
names(poison)
```
#Comme les données sotn ctageorielle, alors il faut les transformer pour passer en grandeur numerique
# Il faut definir les groupe

```{r MFA}
#poison_features = poison[,c[1,4:15]]
PoisonMFA <- MFA(poison, 
                 group=c(2,2,5,6),         # on indique combien de variable il y a ds chaque groupe
                 type=c("s","n","n","n"),  # s:variable continue, n:variable categorielle, 
name.group=c("desc","desc2","symptom","eat"))
# graph = true
```
# groupc(2,  --> "Age"        "Time"
# 2,    -->  "Sick"       "Sex"
# 5,    -->   "Nausea"     "Vomiting"   "Abdominals" "Fever" Diarrhae
# 6)    -->   "Potato"     "Fish"       "Mayo"       "Courgette"  "Cheese"     "Icecream" 

# Par la suite, essayer de choisir qlq points du centre de chaque cluster afin d'interpreter le resultat
# cluster 1
poison[c(14,20),]
# cluster 2
poison[c(5,55),]

## ICA

```{r ICA}
library("fastICA")
DecathlonICA <- fastICA(decathlon[1:10], n.comp = 2)
PlotDecathlon(DecathlonICA$S)

DecathlonRICA <- fastICA(decathlonR[1:10], n.comp = 2)
PlotDecathlon(DecathlonRICA$S)

SwissRollICA <- fastICA(swissroll, n.comp = 2)
PlotSwissRoll(SwissRollICA$S)

ClustersICA <- fastICA(Clusters, n.comp = 2)
PlotClusters(ClustersICA$S)
```

## NMF

```{r NMF}
library("NMF")
DecathlonNMF <- nmf(decathlon[1:10], rank = 2)
PlotDecathlon(basis(DecathlonNMF))
```

## k-PCA

```{r KPCA}
library("kernlab")
DecathlonKPCA <- kpca(decathlon[1:10], features = 2)
PlotDecathlon(as.matrix(scale(decathlon[1:10], scale = FALSE)) %*% pcv(DecathlonKPCA))

DecathlonRKPCA <- kpca(decathlonR[1:10], features = 2)
PlotDecathlon(as.matrix(scale(decathlonR[1:10], scale = FALSE)) %*% pcv(DecathlonRKPCA))

SwissRollKPCA <- kpca(swissroll, features = 2)
PlotSwissRoll(as.matrix(scale(swissroll, scale = FALSE)) %*% pcv(SwissRollKPCA))

```

## Deep Learning: PCA and autoencoders

```{r Keras}
#library(keras)
```

```{r Keras_PCA}
# pca_encoder <-  keras_model_sequential() %>%
#   layer_dense(units = 2, input_shape = c(10))
# pca_decoder <- keras_model_sequential() %>% layer_dense(units = 10, input_shape = c(2))
# pca_autoencoder <- keras_model_sequential() %>% pca_encoder() %>% pca_decoder()
# 
# pca_autoencoder %>% compile(loss = "mse", optimizer = "sgd",
#                         metric= "mse")
# 
# decathlonR100 <- decathlonR %>% slice(rep(seq_len(nrow(decathlonR)),100))
# 
# pca_hist <- pca_autoencoder %>% fit(x = as.matrix(decathlonR100[,1:10]),
#                                     y= as.matrix(decathlonR100[,1:10]),
#                                     epochs = 1000,
#                                     batch_size = 32,
#                                     verbose = 0)
```

```{r keras_pca_plot}
# decathlon_pca_coords <- predict(pca_encoder, x = as.matrix(decathlonR[,1:10]))
# PlotDecathlon(decathlon_pca_coords)
```


```{r keras_ae}
# encoder <- keras_model_sequential() %>%
#   layer_dense(units = 4, activation = "relu", input_shape = c(10)) %>%
#   layer_dense(units = 2)
# decoder <- keras_model_sequential() %>%
#   layer_dense(units = 4, activation = "relu", input_shape = c(2)) %>%
#   layer_dense(units = 10)
# autoencoder <- keras_model_sequential() %>% encoder %>% decoder()
# 
# autoencoder %>% compile(loss = "mse", optimizer = "sgd",
#                         metric= "mse")
# 
# ae_hist <- autoencoder %>% fit(x = as.matrix(decathlonR100[,1:10]),
#                             y= as.matrix(decathlonR100[,1:10]),
#                             epochs = 5000,
#                             batch_size = 32,
#                             verbose = 0)
```

```{r keras_ae_plot}
# decathlon_ae_coords <- predict(encoder, x = as.matrix(decathlonR[,1:10]))
# PlotDecathlon(decathlon_ae_coords)
```


## MDS

```{r MDS}
DistDecathlon <- dist(decathlon[1:10])
DecathlonMDS <- cmdscale(DistDecathlon, k = 2)
PlotDecathlon(DecathlonMDS)

DistDecathlonR <- dist(decathlonR[1:10])
DecathlonRMDS <- cmdscale(DistDecathlonR, k = 2)
PlotDecathlon(DecathlonRMDS)

DistSwissRoll <- dist(swissroll)
SwissRollMDS <- cmdscale(DistSwissRoll, k = 2)
PlotSwissRoll(SwissRollMDS)

DistClusters <- dist(Clusters)
DistUClusters <- dist(unique(Clusters))
ClustersMDS <- cmdscale(DistClusters, k = 2)
PlotClusters(ClustersMDS)
```

## ISOMAP

```{r ISOMAP}
library("vegan")
DecathlonISOMAP <- isomap(DistDecathlon, ndim = 2, k = 5)
PlotDecathlon(DecathlonISOMAP$points)

DecathlonRISOMAP <- isomap(DistDecathlonR, ndim = 2, k = 5)
library("ggplot2")
PlotDecathlon(DecathlonRISOMAP$points)

SwissRollISOMAP <- isomap(DistSwissRoll, ndim = 2, k = 10)
PlotSwissRoll(SwissRollISOMAP$points)
```


## Random Projection

```{r RandomProj}
library("chemometrics")
DecathlonRandom <- RPvectors(2, 10)
PlotDecathlon(as.matrix(decathlon[1:10]) %*% DecathlonRandom)

PlotDecathlon(as.matrix(decathlonR[1:10]) %*% DecathlonRandom)

SwissRollRandom <- RPvectors(2, 3)
PlotSwissRoll(as.matrix(swissroll) %*% SwissRollRandom)

ClustersRandom <- RPvectors(2, 2)
PlotClusters(as.matrix(Clusters) %*% ClustersRandom)
```

## LLE

```{r LLE}
library("lle")
DecathlonLLE <- lle(decathlon[1:10], m = 2, k = 10)
PlotDecathlon(DecathlonLLE$Y)

DecathlonRLLE <- lle(decathlonR[1:10], m = 2, k = 10)
PlotDecathlon(DecathlonRLLE$Y)

SwissRollLLE <- lle(swissroll, m = 2, k = 10)
PlotSwissRoll(SwissRollLLE$Y)

ClustersLLE <- lle(Clusters, m = 2, k = 10)
PlotClusters(ClustersLLE$Y)
```


## t-SNE

```{r TSNE}
library("Rtsne")
DecathlonTSNE <- Rtsne(as.matrix(decathlon[1:10]), perplexity = 10, pca = FALSE)
PlotDecathlon(DecathlonTSNE$Y)

DecathlonRTSNE <- Rtsne(as.matrix(decathlonR[1:10]), perplexity = 10, pca = FALSE)
PlotDecathlon(DecathlonRTSNE$Y)

SwissRollTSNE <- Rtsne(as.matrix(swissroll), perplexity = 30, pca = FALSE)
PlotSwissRoll(SwissRollTSNE$Y)

ClustersTSNE <- Rtsne(as.matrix(unique(Clusters)), perplexity = 30, pca = FALSE)
PlotSwissRoll(ClustersTSNE$Y, Col = 1:nrow(unique(Clusters)))
```

## UMAP

```{r}
library(uwot)

DecathlonUMAP <- umap(as.matrix(decathlon[1:10]))
PlotDecathlon(DecathlonUMAP)

DecathlonRUMAP <- umap(as.matrix(decathlonR[1:10]))
PlotDecathlon(DecathlonRUMAP)

SwissRollUMAP <- umap(as.matrix(swissroll))
PlotSwissRoll(SwissRollUMAP)

ClustersUMAP <- umap(as.matrix(unique(Clusters)))
PlotSwissRoll(ClustersUMAP, Col = 1:nrow(unique(Clusters)))
```
```{r}
Clusters$color = rep(0,nrow(Clusters))
Clusters$color[c(1:50)] = 1
Clusters$color[c(410:560)] = 2
# ggplot(Clusters, aes(V1,V2, col=as.factor(color))) + geom_point()
```

```{r}
ClustersUMAP = as_tibble(ClusterUMAP)
ClustersUMAP$color = rep(0,nrow(ClustersUMAP))
ClustersUMAP$color[c(1:50)] = 1
ClustersUMAP$color[c(410:560)] = 2
ggplot(ClustersUMAP, aes(V1,V2, col=as.factor(color))) + geom_point()
```

#  Graph

```{r Laplacian}
library("igraph")
DecathlonLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistDecathlon/3)), weighted = TRUE),2)
PlotDecathlon(DecathlonLap$X)
DecathlonRLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistDecathlonR/3)), weighted = TRUE),2)
PlotDecathlon(DecathlonRLap$X)
SwissRollLap = embed_laplacian_matrix(graph.adjacency(as.matrix(exp(-DistSwissRoll/3)), weighted = TRUE),2)
PlotSwissRoll(SwissRollLap$X)
```


# Clustering

## K-Means

```{r KMeans}
K <- 4
K2 <- 10

DecathlonRKmeans <- kmeans(decathlonR[1:10], K)  # Kmeans sur ttes els avriables
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRKmeans$cluster))  # je represente sur ces axes

DecathlonRPCAKmeans <- kmeans(DecathlonRPCA$ind$coord[,1:2], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRPCAKmeans$cluster))

PlotDecathlon(DecathlonTSNE$Y, Col = factor(DecathlonRKmeans$cluster))

DecathlonTSNEKmeans <- kmeans(DecathlonTSNE$Y, K)
PlotDecathlon(DecathlonTSNE$Y, Col = factor(DecathlonTSNEKmeans$cluster))

PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonTSNEKmeans$cluster))

ClustersKmeans <- kmeans(Clusters, K2)
PlotClusters(Clusters, Col = factor(ClustersKmeans$cluster))

ClustersTSNEKmeans <- kmeans(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), Col = factor(ClustersTSNEKmeans$cluster))
```

## PAM
# k-Medoid: Ago plus robuste aux pts abhérent

```{r PAM}
DecathlonRPam <- pam(decathlonR[1:10], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRPam$cluster))

DecathlonRPCAPam <- pam(DecathlonRPCA$ind$coord[,1:2], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRPCAPam$cluster))

DecathlonTSNEPam <- pam(DecathlonTSNE$Y, K)
PlotDecathlon(DecathlonTSNE$Y, Col = factor(DecathlonTSNEPam$cluster))

ClustersPam <- kmeans(Clusters, K2)
PlotClusters(Clusters, Col = factor(ClustersPam$cluster))

ClustersTSNEPam <- kmeans(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), Col = factor(ClustersTSNEPam$cluster))
```

```{r}
# TO COMPLETE : PLOT de La sihoulette. Il permet d evaluer quelle methode de clustering est la meilleure
library(cluster)

distances = dist(decathlonR[1:10])
K=15
DecathlonRKmeans ← kmeans(decathlonR[1:10], K)
DecathlonTSNEKmeans ← kmeans(DecathlonTSNE$Y, K)
PlotDecathlon(DecathlonTSNEY , Col=factor(DecathlonRKmeanscluster)) 
PlotDecathlon(DecathlonTSNEY , Col=factor(DecathlonTSNEKmeanscluster)) 
plot(silhouette(DecathlonRKmeans$cluster,distances))
plot(silhouette(DecathlonTSNEKmeans$cluster,distances))

```

## GMM

```{r GMM}
# Gaussien Mixture Model
# Sachant le nro de Cluster, mes Xi sont Gaussians, 
library("Rmixmod")
DecathlonGMM <- mixmodCluster(decathlon[1:10], K)
PlotDecathlon(DecathlonPCA$ind$coord, Col = factor(DecathlonGMM@bestResult@partition))

DecathlonRGMM <- mixmodCluster(decathlonR[1:10], K)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRGMM@bestResult@partition))

ClustersGMM <- mixmodCluster(Clusters, K2)
PlotClusters(Clusters, Col = factor(ClustersGMM@bestResult@partition))
```

## PLSA / LDA

```{r LDA}
library(topicmodels)
data("AssociatedPress")
# AssociatedPress: 2246 documents avec 10473 words
k = 5  # topics count
ap_lda <- LDA(AssociatedPress, k , control = list(seed = 1234))
ap_lda
terms(ap_lda,10)
```

## DBSCAN
# Calcul du nbre de points ds les petites feentres, ensite faire avancer les fenetre, dès qu'il n'y a plus de pts, ceci voudrait dire que la frontiere du cluter a été atteinte
```{r DBSCAN}
library("fpc")

DecathlonDBScan <- dbscan(decathlon[1:10], 10)
PlotDecathlon(DecathlonPCA$ind$coord, Col = factor(DecathlonDBScan$cluster))

DecathlonRDBScan <- dbscan(decathlonR[1:10], 3)
PlotDecathlon(DecathlonRPCA$ind$coord, Col = factor(DecathlonRDBScan$cluster))

ClustersDBScan <- dbscan(Clusters, .2)
PlotClusters(Clusters, Col = factor(ClustersDBScan$cluster))

ClustersTSNEDBScan <- dbscan(ClustersTSNE$Y, 2)
PlotClusters(unique(Clusters), Col = factor(ClustersTSNEDBScan$cluster))
```

## PdfCluster

```{r PdfCluster}
library("pdfCluster")
ClustersPdf <- pdfCluster(Clusters)
PlotClusters(Clusters, Col = factor(ClustersPdf@clusters))
```

## Mean Shift
```{r MeanShift}
library("LPCM")
ClustersMS <- ms(Clusters, h = .04)
PlotClusters(Clusters, Col = factor(ClustersMS$cluster.label))
```


## Linkage
# Agglomerative Cluster
```{r Linkage}
library("ggdendro")
library("fastcluster")
ClustersMLD <- hclust(DistClusters, method = "single")
ggdendrogram(ClustersMLD)
ClustersML <- cutree(ClustersMLD, k = K2)
PlotClusters(Clusters, Col = factor(ClustersML))

ClustersALD <- hclust(DistClusters, method = "average")
ggdendrogram(ClustersALD)
ClustersAL <- cutree(ClustersALD, k = K2)
PlotClusters(Clusters, Col = factor(ClustersAL))

ClustersMMLD <- hclust(DistClusters, method = "complete")
ggdendrogram(ClustersMMLD)
ClustersMML <- cutree(ClustersMMLD, k = K2)
PlotClusters(Clusters, Col = factor(ClustersMML))
```

## WARD

```{r Ward}
ClustersWardD <- hclust(DistClusters, method = "ward.D2")
ggdendrogram(ClustersWardD)
ClustersWard <- cutree(ClustersWardD, k = K2)
PlotClusters(Clusters, Col = factor(ClustersWard))
```

## DIANA

```{r Diana}
ClustersDianaD <- as.hclust(diana(Clusters))
ggdendrogram(ClustersDianaD)
ClustersDiana <- cutree(ClustersDianaD, k = K2)
PlotClusters(Clusters, Col = factor(ClustersDiana))
```

## Affinity Propagation

```{r AffProp}
library("apcluster")
ClustersAF <- apcluster(negDistMat(r=2), Clusters)
PlotClusters(Clusters, labels(ClustersAF))
```


## CLARA

```{r Clara}
ClustersClara <- clara(Clusters, K2)
PlotClusters(Clusters, Col = factor(ClustersClara$clustering))

ClustersSNEClara <- clara(ClustersTSNE$Y, K2)
PlotClusters(unique(Clusters), Col = factor(ClustersSNEClara$clustering))
```

